{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Analysing drum patterns from MIDI files\n",
    "\n",
    "In our first lesson we want to get to know how to work with datasets so we can\n",
    "\n",
    "* parse a dataset\n",
    "* analyse the dataset so it matches our expectations and we did not screw up during parsing\n",
    "\n",
    "After this is done we want to take a look at how we can generate new drum patterns from the existing one.\n",
    "But in order to do this we want to take a look at the quantisation (?) of our patterns.\n",
    "\n",
    "The cleaning of the dataset and setting the data up properly takes the most time in such experiments but if one makes errors here those errors will propagate through our system - so its good to spend some time at this task."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import glob\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "np.random.seed(42)  # makes the randomness deterministic"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Getting the dataset\n",
    "\n",
    "As our methods rely on data we need a way to obtain such data.\n",
    "Of course we start to get into difficult teritory here from a copyright point of view - so for now we will rely on public domain datasets?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Parsing the dataset\n",
    "\n",
    "When working with large sets of files the unix utility [glob](https://en.wikipedia.org/wiki/Glob_(programming)) comes in handy as we can describe the pattern of the file paths we want to match instead of listing all files.\n",
    "\n",
    "When we take a quick look at the data set we see that there are two occurences of common file pattens:\n",
    "\n",
    "```\n",
    "midi_dataset/C/Celine Dion - (If-There-Was) Any Other Way.mid\n",
    "midi_dataset/A/A/A AH.The living daylights.mid\n",
    "```\n",
    "\n",
    "So we have either\n",
    "\n",
    "* a single character folder in which `.mid` files are\n",
    "* a single character folder with another single character folder in which `.mid` files are\n",
    "\n",
    "Some googling for *glob any depth only extension* reveals [this stack overflow answer](https://stackoverflow.com/a/14798263/3475778) from which we can now deduce our glob pattern to match the files."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 39712 midi files in dataset\n"
     ]
    }
   ],
   "source": [
    "GLOB_PATTERN = '../datasets/midi_dataset/**/*.mid'\n",
    "midi_files = glob.glob(GLOB_PATTERN, recursive=True)\n",
    "print(f'Found {len(midi_files)} midi files in dataset')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['../datasets/midi_dataset/A/A/ArminVanBuuren_-_ComingHome__karimstar95_20120526025524.mid',\n",
       "       '../datasets/midi_dataset/R/R/RevolutionsOverture.mid',\n",
       "       '../datasets/midi_dataset/P/P/pink-dont_let_me_get_me.mid',\n",
       "       '../datasets/midi_dataset/S/S/Sixpence_None_The_Richer_Kiss_Me.mid',\n",
       "       '../datasets/midi_dataset/T/T/The_Everly_Brothers_-_Bye_Bye_Love.mid'],\n",
       "      dtype='<U265')"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# select 5 random files\n",
    "np.random.choice(midi_files, 5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But how are sure that we matched every midi file in our folder?\n",
    "We can simply match every file in our dataset directory and show us the differences by using [sets](https://realpython.com/python-sets/)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Did not match 765 files\n"
     ]
    }
   ],
   "source": [
    "missed_files = set(glob.glob('../datasets/midi_dataset/**/*.*', recursive=True)) - set(midi_files)\n",
    "print(f'Did not match {len(missed_files)} files')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It turns out that we missed some files.\n",
    "Lets take a look at them using [random.choice](https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html) from the numpy library.\n",
    "But as this function does not work with sets we need to transform the set to a list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([\"../datasets/midi_dataset/S/S/STATUS QUO.What you're proposin'.MID\",\n",
       "       '../datasets/midi_dataset/T/T/THE SPARKS.When i kiss you.MID',\n",
       "       '../datasets/midi_dataset/M/M/Music of the Third Kind (061114).MID',\n",
       "       '../datasets/midi_dataset/T/T/THE ARCHIES.Sugar sugar.MID',\n",
       "       '../datasets/midi_dataset/S/S/STING.This cowboy song.MID'],\n",
       "      dtype='<U114')"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.choice(list(missed_files), 5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It seems there are files missing that have a capitalized file extension `.MID`.\n",
    "\n",
    "But lets not rely on the few examples, lets use a [list comprehension](https://realpython.com/list-comprehension-python/) to filter out all examples that are not ending in a capitalized manner."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['../datasets/midi_dataset/S/S/S.ROGERS BAND.Alzati la gonna K.Mid',\n",
       " '../datasets/midi_dataset/M/M/MM-personal jesus.midi',\n",
       " '../datasets/midi_dataset/L/L/littlebrownjug.midi',\n",
       " '../datasets/midi_dataset/S/S/Stripped [Rammstein].MIDi',\n",
       " '../datasets/midi_dataset/W/W/Wollt ihr das bett in flammen sehen.Mid',\n",
       " '../datasets/midi_dataset/M/M/mike_koglin_&_dj_uto__time__zoik.midi',\n",
       " '../datasets/midi_dataset/S/S/standbyyourman.midi',\n",
       " '../datasets/midi_dataset/R/R/rhapsodyinblue.midi']"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[f for f in list(missed_files) if not f.endswith('.MID')]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We see that we are still missing the files that have `.Mid`, `.midi` and `.MIDi` as extension.\n",
    "If we include these we will now have matched all files of our dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 40477 midi files in dataset\n"
     ]
    }
   ],
   "source": [
    "for ext in ['MID', 'Mid', 'midi', 'MIDi']:\n",
    "    MID_GLOB_PATTERN = f'../datasets/midi_dataset/**/*.{ext}'\n",
    "    midi_files += glob.glob(MID_GLOB_PATTERN, recursive=True)\n",
    "print(f'Found {len(midi_files)} midi files in dataset')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Did not match 0 files\n"
     ]
    }
   ],
   "source": [
    "missed_files = set(glob.glob('../datasets/midi_dataset/**/*.*', recursive=True)) - set(midi_files)\n",
    "print(f'Did not match {len(missed_files)} files')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Of course we could have just matched every file in the directory but then we would not have those exercises and one will at one point work with *dirty* datasets so its good to have at least some experience on how to inspect just the files of our dataset.\n",
    "\n",
    "Also it is always a good idea to only include such files into the dataset that we expect because having an unexpected file in the dataset needs to be avoided because this can mess up our results."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inspecting the data\n",
    "\n",
    "Now as we have all file paths available it is a good practice to take a first look at the data.\n",
    "We need to understand how the information we are interested in is accessible and also that it is probably not standardized - as we have seen above with the filenames already. \n",
    "\n",
    "To parse the midi files we will use the python library [music21](https://web.mit.edu/music21/) from the MIT.\n",
    "The [docs](https://web.mit.edu/music21/doc/moduleReference/moduleConverter.html) reveal that `music21.converter` seems to be the proper package."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "from music21 import converter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Selected ../datasets/midi_dataset/A/A/AreYouAfraidOfTheDark.mid as example MIDI file\n"
     ]
    }
   ],
   "source": [
    "example_midi_file = np.random.choice(midi_files, 1)[0]\n",
    "print(f'Selected {example_midi_file} as example MIDI file')\n",
    "example_score = converter.parse(example_midi_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "# a small hack so we can capture the output of\n",
    "# music21 and shorten it so our notebook does not\n",
    "# get spammed\n",
    "# from https://stackoverflow.com/a/16571630/3475778\n",
    "\n",
    "from io import StringIO \n",
    "import sys\n",
    "\n",
    "class Capturing(list):\n",
    "    def __enter__(self):\n",
    "        self._stdout = sys.stdout\n",
    "        sys.stdout = self._stringio = StringIO()\n",
    "        return self\n",
    "    \n",
    "    def __exit__(self, *args):\n",
    "        self.extend(self._stringio.getvalue().splitlines())\n",
    "        del self._stringio    # free up some memory\n",
    "        sys.stdout = self._stdout"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{0.0} <music21.stream.Part 0x10c07ed30>\n",
      "    {0.0} <music21.instrument.Piano 'Theme from Love Story: piano'>\n",
      "    {0.0} <music21.key.Key of C major>\n",
      "    {0.0} <music21.stream.Voice 0x126b2e970>\n",
      "        {0.0} <music21.note.Rest rest>\n",
      "        {8.0} <music21.note.Note A>\n",
      "        {8.75} <music21.note.Note C>\n",
      "        {9.0} <music21.note.Note E>\n",
      "        {9.25} <music21.note.Rest rest>\n",
      "        {9.3333} <music21.note.Note A> \n",
      "...\n"
     ]
    }
   ],
   "source": [
    "with Capturing() as output:\n",
    "    example_score.show('text')\n",
    "\n",
    "print('\\n'.join(output[0:10]), '\\n...')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see a single score can take some time to process and analyse.\n",
    "So before we process every file from our dataset we should take a look at a subset to watch out for any patterns.\n",
    "\n",
    "Also it is worth making some research so we can reduce the amount of data we need to process.\n",
    "From the [wikipedia article on General MIDI (GM)](https://en.wikipedia.org/wiki/General_MIDI#Percussive) we can see that percussive tracks should be on channel 10.\n",
    "So lets write a parser function wihch only return the notes that are assigned to channel 10."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import Optional\n",
    "\n",
    "from music21 import midi, stream\n",
    "\n",
    "def parse_midi(midi_path: str, only_drums: bool = True) -> Optional[stream.Stream]:\n",
    "    \"\"\"\n",
    "    This function uses the MIDI parser of music21 to filter out the drum sounds\n",
    "    that are assigned to channel 10.\n",
    "    \"\"\"\n",
    "    mf = midi.MidiFile()\n",
    "    mf.open(midi_path)\n",
    "    try:\n",
    "        mf.read()\n",
    "    except midi.MidiException:\n",
    "        print(f'Encountered invalid MIDI File {midi_path}')\n",
    "        return\n",
    "    finally:\n",
    "        mf.close()\n",
    "    if only_drums:\n",
    "        # we dont want to change anything we are iterating over\n",
    "        # so we use non-pythonic index for\n",
    "        for i in range(len(mf.tracks)):\n",
    "            mf.tracks[i].events = [ev for ev in mf.tracks[i].events if ev.channel == 10]\n",
    "    try:\n",
    "        return midi.translate.midiFileToStream(midi)\n",
    "    except AttributeError:\n",
    "        return"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "musikinformatik_sose2021",
   "language": "python",
   "name": "musikinformatik_sose2021"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}